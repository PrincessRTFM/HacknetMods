using System;

using Hacknet;
using Hacknet.Effects;
using Hacknet.Gui;

using Microsoft.Xna.Framework;

using Pathfinder.Executable;

namespace PrincessRTFM.Hacknet.BackdoorExploit;

public class BackdoorExe: GameExecutable {
	public const float
		TIME_TRIGGER = 15f,
		TIME_INSTALL = 10f,
		TIME_ERROR = 6f,
		TIME_IDLE = 3f;
	public const string
		MSG_NO_TARGET = "Not connected to a target",
		MSG_ALREADY_ADMIN = "You are already an admin",
		MSG_REQUIRES_ADMIN = "Admin access required",
		LBL_PREFIX_WORKING = "STATUS:",
		LBL_PREFIX_ERRORED = "ERR:",
		LBL_LOST_CONNECTION = "E_CONNLOST",
		LBL_NOT_INSTALLED = "E_CONNREFUSED",
		LBL_TRIGGERING = "injecting...",
		LBL_INSTALLING = "compiling...",
		LBL_COMPLETE = "finished",
		LBL_BIG_SUCCESS = "SUCCESS",
		LBL_BIG_FAILURE = "FAILED";
	public const int LABEL_HEIGHT = 16;
	public enum DisplayState {
		Install,
		Trigger,
		Idle,
		ConnectionLost,
		NotInstalled,
	}

	public Color RainColourTriggering => this.os.lockedColor;
	public Color RainColourInstalling => this.os.highlightColor;
	public Color RainColourIdle => this.os.unlockedColor;
	public Color RainColourError => this.os.warningColor;
	public Color StatusLabelColour => this.os.exeModuleTitleText;
	public Color ErrorFillColour => this.os.brightLockedColor * 0.6f;
	public Color ErrorTextColour => this.os.warningColor;
	public Color SuccessFillColour => this.os.brightUnlockedColor * 0.6f;
	public Color SuccessTextColour => this.os.unlockedColor;

	private string ownIP => this.os.thisComputer.ip;
	private string currentIP => this.os.connectedComp?.ip ?? string.Empty;
	private Computer targetComp => Programs.getComputer(this.os, this.targetIP);

	private bool completedSuccessfully;
	private bool lostConnectionToTarget;
	private bool targetRefusedConnection;
	private DisplayState originalState;

	public DisplayState State => this.Finished
		? DisplayState.Idle
		: this.ConnectionLost
		? DisplayState.ConnectionLost
		: this.ConnectionRefused
		? DisplayState.NotInstalled
		: this.originalState;
	public bool ConnectionLost {
		get => !this.Finished && this.lostConnectionToTarget;
		set => this.lostConnectionToTarget |= value;
	}
	public bool ConnectionRefused {
		get => !this.Finished && this.targetRefusedConnection;
		set => this.targetRefusedConnection |= value;
	}
	public bool Finished {
		get => this.completedSuccessfully;
		protected set => this.completedSuccessfully |= value;
	}
	public float StageTimeRemaining => this.State switch {
		DisplayState.Install => TIME_INSTALL,
		DisplayState.Trigger => TIME_TRIGGER,
		DisplayState.Idle => TIME_IDLE,
		DisplayState.ConnectionLost or DisplayState.NotInstalled => TIME_ERROR,
		_ => 0,
	} - this.Lifetime;


	protected RaindropsEffect Raindrops { get; private set; } = null!; // they keep falling on my head, they keep falling on my head...
	protected ConnectedNodeEffect TargetHighlight { get; private set; } = null!;
	protected Vector2 TargetBasePos { get; private set; }

	public BackdoorExe() : base() {
		this.IgnoreMemoryBehaviorPrint = false;

		this.IdentifierName = Core.PROGRAM_NAME;
		this.name = Core.PROGRAM_NAME;

		this.ramCost = 100;
	}

	public override void OnInitialize() {
		base.OnInitialize();

		this.Raindrops = new() {
			MaxVerticalLandingVariane = 0.05f,
			FallRate = 1f,
		};
		this.Raindrops.Init(this.os.content);
		this.TargetHighlight = new(this.os) {
			color = this.os.warningColor,
		};
		// this can't just be set to the actual target position, because the chaos sorting algorithm randomises locations every draw call
		this.TargetBasePos = new Vector2(this.os.netMap.bounds.X, this.os.netMap.bounds.Y) + new Vector2(NetworkMap.NODE_SIZE / 2f);

		if (this.targetComp is null) {
			this.Result = CompletionResult.Error;
			this.CanAddToSystem = false;
			this.os.write(MSG_NO_TARGET);
		}
		else if (this.targetComp.PlayerHasAdminPermissions()) { // if you're an admin, install the backdoor - even if it's already there - but ONLY if there's no flag disabling that
			if (this.os.Flags.HasFlag(Core.FLAG_PREVENT_INSTALL)) {
				this.Result = CompletionResult.Error;
				this.CanAddToSystem = false;
				this.os.write(MSG_ALREADY_ADMIN);
			}
			else {
				this.originalState = DisplayState.Install;
			}
		}
		else if (this.os.Flags.HasFlag(Core.FLAG_PREVENT_TRIGGER)) { // extensions may want to make you install it as part of a mission without letting you sneak back in after
			this.Result = CompletionResult.Error;
			this.CanAddToSystem = false;
			this.os.write(MSG_REQUIRES_ADMIN);
		}
		else { // triggering it when it's not installed is handled by the update/draw calls
			this.originalState = DisplayState.Trigger;
		}

		if (this.CanAddToSystem) {
			this.os.netMap.DimNonConnectedNodes = true;
		}
	}

	protected Rectangle RealDrawSpace {
		get {
			Rectangle area = this.GetContentAreaDest();
			area.Height -= LABEL_HEIGHT;
			//area = Utils.InsetRectangle(area, 1);
			return area;
		}
	}
	protected void DrawStatusLabel() {
		string text = this.State switch {
			DisplayState.Install => LBL_PREFIX_WORKING + LBL_INSTALLING,
			DisplayState.Trigger => LBL_PREFIX_WORKING + LBL_TRIGGERING,
			DisplayState.Idle => LBL_PREFIX_WORKING + LBL_COMPLETE,
			DisplayState.ConnectionLost => LBL_PREFIX_ERRORED + LBL_LOST_CONNECTION,
			DisplayState.NotInstalled => LBL_PREFIX_ERRORED + LBL_NOT_INSTALLED,
			_ => "error", // unpossible!
		};
		Rectangle content = this.GetContentAreaDest();
		if (content.Height < LABEL_HEIGHT)
			return;
		Rectangle dest = new(content.X, content.Bottom - LABEL_HEIGHT, content.Width, LABEL_HEIGHT);
		TextItem.doFontLabelToSize(dest, text, GuiData.detailfont, this.StatusLabelColour);
	}
	protected void DrawStatusOverlay() {
		int popupMargin = 6, popupPadding = 4, popupHeight = 30;
		Rectangle content = this.RealDrawSpace;
		if (content.Height < popupHeight)
			return;
		Rectangle overlay = new(content.X + popupMargin, content.Center.Y - (popupHeight / 2), content.Width - (popupMargin * 2), popupHeight);
		if (this.Finished) {
			this.spriteBatch.Draw(Utils.white, overlay, this.SuccessFillColour);
			TextItem.doFontLabelToSize(Utils.InsetRectangle(overlay, popupPadding), LBL_BIG_SUCCESS.ToUpper(), GuiData.titlefont, this.SuccessTextColour);
		}
		else if (this.ConnectionLost || this.ConnectionRefused) {
			this.spriteBatch.Draw(Utils.white, overlay, this.ErrorFillColour);
			TextItem.doFontLabelToSize(Utils.InsetRectangle(overlay, popupPadding), LBL_BIG_FAILURE.ToUpper(), GuiData.titlefont, this.ErrorTextColour);
		}
	}
	protected void DrawTargetHighlight() => this.TargetHighlight.draw(this.spriteBatch, this.TargetBasePos + this.os.netMap.GetNodeDrawPos(this.targetComp));

	public override void Draw(float t) {
		base.Draw(t);
		this.drawOutline();
		this.drawTarget();
		this.DrawTargetHighlight();
		float drops = Math.Max(0f, this.State switch {
			DisplayState.Install => this.Lifetime * 4f,
			DisplayState.Trigger => this.Lifetime * 3f,
			DisplayState.Idle => TIME_IDLE - this.Lifetime,
			_ => TIME_ERROR - this.Lifetime,
		});
		Color colour = this.State switch {
			DisplayState.Install => this.RainColourInstalling,
			DisplayState.Trigger => this.RainColourTriggering,
			DisplayState.Idle => this.RainColourIdle,
			_ => this.RainColourError,
		};
		Rectangle dest = this.RealDrawSpace;
		if (dest.Height < 2)
			return;
		this.Raindrops.Update(t, drops);
		this.Raindrops.Render(dest, this.spriteBatch, colour, 4, 17);
		this.DrawStatusOverlay();
		this.DrawStatusLabel();
	}

	public override void OnUpdate(float delta) {

		if (this.targetIP != this.currentIP) { // handle disconnections
			if (!this.Finished && !this.ConnectionLost) {
				this.Stopped();
				this.ConnectionLost = true;
				this.Lifetime = 0;
			}
		}

		if (this.StageTimeRemaining <= 0) {
			if (this.Finished) {
				this.isExiting = true;
				this.Result = CompletionResult.Success;
			}
			else if (this.ConnectionLost || this.ConnectionRefused) {
				this.isExiting = true;
				this.Result = CompletionResult.Success;
			}
			else if (BackdoorExploit.IsBackdoorInstalled(this.targetComp) || this.targetComp.PlayerHasAdminPermissions()) {
				this.Success();
			}
			else {
				this.os.write("Backdoor connection refused");
				this.ConnectionRefused = true;
			}

			if (!this.isExiting)
				this.Lifetime = 0;
		}
	}

	public override void OnComplete() => this.Stopped(); // in case it's killed or something breaks
	public void Stopped() => this.os.netMap.DimNonConnectedNodes = false;
	public void Success() {
		this.Stopped();
		Computer target = this.targetComp;
		if (target is not null) {
			switch (this.State) {
				case DisplayState.Install:
					BackdoorExploit.Install(target);
					this.os.write("Backdoor installed");
					break;
				case DisplayState.Trigger:
					target.giveAdmin(this.ownIP);
					this.os.write("Backdoor successful");
					this.os.write("Admin access acquired");
					break;
			}
			this.Finished = true;
		}
		else {
			this.ConnectionLost = true;
		}
	}

}

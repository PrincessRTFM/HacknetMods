using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Reflection;

using BepInEx.Configuration;

using Hacknet;

using Pathfinder.Event.Pathfinder;
using Pathfinder.Meta.Load;

using PrincessRTFM.Hacknet.Lib;

namespace PrincessRTFM.Hacknet.BackdoorExploit.Config;

internal static class ModSettings {
	private const StringComparison NOCASE = StringComparison.OrdinalIgnoreCase;
	internal const string
		SECTION_EXE_SETTINGS = "program",
		SECTION_EXPLOIT_SETTINGS = "exploit",
		COMMAND_RUNTIME_CONFIG = "configBackdoor";

	#region Backend fields
#pragma warning disable IDE0044 // Add readonly modifier - assigned by reflection

	[Setting(SECTION_EXE_SETTINGS, 30f, $"The duration (in seconds) that {Core.PROGRAM_NAME}.exe runs for when attempting to activate the backdoor exploit"
		+ "\nIt will run for the full time here even if the exploit isn't installed on the target computer")]
	private static ConfigEntry<float> cBackdoorTriggerTime = null!;

	[Setting(SECTION_EXE_SETTINGS, 20f, $"The duration (in seconds) that {Core.PROGRAM_NAME}.exe runs for when installing the backdoor exploit to a target"
		+ "\nIt will run for the full time here even if the exploit is already installed")]
	private static ConfigEntry<float> cBackdoorInstallTime = null!;

	[Setting(SECTION_EXE_SETTINGS, 6f, $"The duration (in seconds) that {Core.PROGRAM_NAME}.exe will REMAIN active after an error,"
		+ "\nsuch as disconnecting while it's working or attempting to trigger the exploit on a target that doesn't have it installed")]
	private static ConfigEntry<float> cBackdoorErrorTime = null!;

	[Setting(SECTION_EXE_SETTINGS, 3f, $"The duration (in seconds) that {Core.PROGRAM_NAME}.exe will REMAIN active after successfully completing its task")]
	private static ConfigEntry<float> cBackdoorIdleTime = null!;

	[Setting(SECTION_EXPLOIT_SETTINGS, "/sys", "The folder that the exploit file is installed to")]
	private static ConfigEntry<string> cExploitFolder = null!;

	[Setting(
		SECTION_EXPLOIT_SETTINGS,
#if DEBUG
		"sysv.dll",
#else
		"netcfgx.dll",
#endif
		"The name of the file that the exploit is installed to")]
	private static ConfigEntry<string> cExploitFilename = null!;

#pragma warning restore IDE0044 // Add readonly modifier
	#endregion

	#region Interface layer properties

	public static float BackdoorTriggerTime {
		get => cBackdoorTriggerTime.Value;
		set => cBackdoorTriggerTime.Value = value;
	}

	public static float BackdoorInstallTime {
		get => cBackdoorInstallTime.Value;
		set => cBackdoorInstallTime.Value = value;
	}

	public static float BackdoorErrorTime {
		get => cBackdoorErrorTime.Value;
		set => cBackdoorErrorTime.Value = value;
	}

	public static float BackdoorIdleTime {
		get => cBackdoorIdleTime.Value;
		set => cBackdoorIdleTime.Value = value;
	}

	public static string ExploitFolder {
		get => cExploitFolder.Value;
		set => cExploitFolder.Value = value;
	}

	public static string ExploitFilename {
		get => cExploitFilename.Value;
		set => cExploitFilename.Value = value;
	}

	#endregion

	private static readonly ReadOnlyDictionary<string, FieldInfo> allConfigEntryFields = new(
		typeof(ModSettings).GetFields(BindingFlags.Static | BindingFlags.NonPublic)
			.Where(f => f.Name.StartsWith("c") && f.GetCustomAttribute<SettingAttribute>() is not null)
			.ToDictionary(f => f.Name)
		);
	private static readonly ReadOnlyDictionary<string, PropertyInfo> allSettingsProperties = new(
		typeof(ModSettings).GetProperties(BindingFlags.Static | BindingFlags.Public)
			.Where(p => allConfigEntryFields.ContainsKey($"c{p.Name}"))
			.ToDictionary(p => p.Name)
		);

	internal static bool Init() {
		ConfigFile cfg = Core.Instance.ActiveConfig;
		if (cfg is null)
			return false;

		if (allConfigEntryFields.Count == 0) {
			Console.ForegroundColor = ConsoleColor.Red;
			Console.WriteLine("Failed to reflect settings fields!");
			Console.ResetColor();
			return false;
		}

		Type tString = typeof(string);
		MethodInfo genericBinder = typeof(ConfigFile).GetMember(nameof(ConfigFile.Bind), MemberTypes.Method, BindingFlags.Public | BindingFlags.Instance)
			.Cast<MethodInfo>()
			.First(m => {
				ParameterInfo[] args = m.GetParameters();
				return args.Length == 4 && args[0].ParameterType == tString && args[1].ParameterType == tString && args[3].ParameterType == tString;
			});

		foreach (FieldInfo field in allConfigEntryFields.Values) {
			SettingAttribute tag = field.GetCustomAttribute<SettingAttribute>();
			Type settingType = field.FieldType.GenericTypeArguments[0];
			string section = tag.Section;
			string key = field.Name.Substring(1);
			string desc = tag.Description;
			object initial = tag.Default;
			object entry = genericBinder.MakeGenericMethod(settingType).Invoke(cfg, [section, key, initial, desc])
				?? throw new NullReferenceException($"failed to reflectively bind setting {key}");
			if (!field.FieldType.IsAssignableFrom(entry.GetType())) {
				throw new InvalidOperationException($"cannot reflectively assign bound setting {key}",
					new InvalidCastException($"type mismatch: bound setting type {entry.GetType().Name} cannot be assigned to field type {field.FieldType}"));
			}
			field.SetValue(null, entry);
			Console.WriteLine($"Reflectively bound setting {key} to field {field.Name}");
		}

		return true;
	}

	internal static void TabCompletion(BuildAutocompletesEvent evt) {
#if DEBUG
		Terminal? term = OS.currentInstance?.terminal;
		if (term is null)
			return;
		string input = term.currentLine;
		if (string.IsNullOrWhiteSpace(input))
			return;
		Console.WriteLine($"Autocompleting for {input}");
		string[] words = input.Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
		if (!words[0].Equals(COMMAND_RUNTIME_CONFIG, NOCASE))
			return;
		string[] suggest = ((IEnumerable<string>)(words.Length switch {
			2 => [
				"help",
				"list",
				"get",
				"set",
				"reset",
			],
			3 => allSettingsProperties.Keys,
			_ => [],
		})).ToArray();
		string last = words[words.Length - 1];
		if (suggest.Length > 0) {
			Console.WriteLine($"Adding autocomplete entries ({suggest.Length}): {string.Join(", ", suggest)}");
			evt.Autocompletes.AddRange(suggest.Where(s => s.StartsWith(last, NOCASE)));
		}
	}

	[Command(COMMAND_RUNTIME_CONFIG)]
	private static void playerConfigurationCommand(OS os, string[] argv) {
		string cmd = "help", setting = string.Empty, value = string.Empty;
		// remember the command itself is always passed as first argument
		if (argv.Length > 1)
			cmd = argv[1].ToLower();
		if (argv.Length > 2)
			setting = argv[2];
		if (argv.Length > 3)
			value = argv[3];

		switch (cmd) {
			case "help": {
					os.Print($"Usage: {argv[0]} <subcommand> [<arguments...>]");
					os.Print("> help - display this help");
					os.Print("> list - list all settings as \"<type> <name> = <value> (<original>)\"");
					os.Print("> get <setting> - get the current and default values of a specific setting");
					os.Print("> set <setting> <value> - change the value of a specific setting");
					os.Print("> reset <setting> - return a setting to its default value");
					os.Print("Setting names are case sensitive and must be typed EXACTLY.");
				}
				break;
			case "list": {
					foreach (KeyValuePair<string, PropertyInfo> p in allSettingsProperties) {
						string name = p.Key;
						string type = (p.Value.PropertyType?.UnderlyingSystemType ?? p.Value.PropertyType!).Name.ToLower();
						object current = p.Value.GetValue(null);
						object original = allConfigEntryFields[$"c{name}"].GetCustomAttribute<SettingAttribute>().Default;
						os.Print($"{type} {name} = {current} ({original})");
					}
				}
				break;
			case "get": {
					if (allSettingsProperties.TryGetValue(setting, out PropertyInfo p)) {
						string type = (p.PropertyType?.UnderlyingSystemType ?? p.PropertyType!).Name.ToLower();
						object current = p.GetValue(null);
						object original = allConfigEntryFields[$"c{setting}"].GetCustomAttribute<SettingAttribute>().Default;
						os.Print($"{type} {setting} = {current} ({original})");
					}
				}
				break;
			case "set": {
					if (allSettingsProperties.TryGetValue(setting, out PropertyInfo p)) {
						Type type = p.PropertyType;
						object original = p.GetValue(null);
						try {
							object parsed = Convert.ChangeType(value, type) ?? throw new InvalidCastException();
							p.SetValue(null, parsed);
							os.Print($"{setting} changed from {original} to {parsed}");
						}
						catch {
							os.Print($"Invalid value \"{value}\" for {type.Name.ToLower()} setting {setting}");
						}
					}
				}
				break;
			case "reset": {
					if (allSettingsProperties.TryGetValue(setting, out PropertyInfo p)) {
						object current = p.GetValue(null);
						object original = allConfigEntryFields[$"c{setting}"].GetCustomAttribute<SettingAttribute>().Default;
						p.SetValue(null, original);
						os.Print($"{setting} reverted from {current} to {original}");
					}
				}
				break;
			default:
				os.Print($"Unknown subcommand: {cmd}");
				break;
		}
#endif
	}

}

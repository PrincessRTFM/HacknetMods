using System;
using System.Linq;
using System.Reflection;

using BepInEx;
using BepInEx.Configuration;
using BepInEx.Hacknet;

using Hacknet;

using Pathfinder.Event;
using Pathfinder.Event.Loading;
using Pathfinder.Event.Pathfinder;
using Pathfinder.Executable;

using PrincessRTFM.Hacknet.BackdoorExploit.Config;

namespace PrincessRTFM.Hacknet.BackdoorExploit;

[BepInPlugin(GUID, NAME, VERSION)]
[BepInDependency(Pathfinder.PathfinderAPIPlugin.ModGUID)]
public class Core: HacknetPlugin {
	public const string
		GUID = $"PrincessRTFM.{NAME}",
		NAME = "BackdoorExploit",
		VERSION = "1.0.0";

	public const string PROGRAM_NAME = "Backdoor";
	public const string XML_ID = "#BACKDOOR_EXE#";
	public const string
		FLAG_PREVENT_AUTO_ADD_EXE = "NO_ADD_BACKDOOR_EXE",
		FLAG_HAS_AUTO_ADDED_EXE = "ADDED_BACKDOOR_EXE",
		FLAG_PREVENT_INSTALL = "NO_INSTALL_BACKDOOR",
		FLAG_PREVENT_TRIGGER = "NO_TRIGGER_BACKDOOR";

	public static readonly string TypeName = typeof(Core).FullName;

	private static Core? singleton;
	public static Core Instance {
		get => singleton ?? throw new InvalidOperationException($"{TypeName} has not yet been instantiated!", new NullReferenceException("singleton instance is null"));
		private set {
			if (singleton is not null)
				throw new InvalidOperationException($"Only one instance of {TypeName} can exist at a time!");
			singleton = value;
		}
	}

	public bool Loaded { get; private set; } = false;
	public string ProgramData { get; private set; } = string.Empty;
	public ConfigFile ActiveConfig { get; private set; } = null!;

	public override bool Load() {
		Instance = this;

		Console.WriteLine($"{NAME} loading...");

		MSRandom rng = new(5312497);

		if (!this.initConfig()) {
			Console.WriteLine("Aborting load");
			return false;
		}

		Console.WriteLine("Registering executable...");
		BackdoorExploit.Init(rng);
		ExecutableManager.RegisterExecutable<BackdoorExe>(XML_ID);
		this.ProgramData = ExecutableManager.GetCustomExeData(XML_ID);

		Console.WriteLine("Registering handlers...");
		Type baseEvent = typeof(PathfinderEvent);
		Type nothing = typeof(void);
		Type manager = typeof(EventManager<>);
		MethodInfo[] handlers = this.GetType()
			.GetMethods(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.DeclaredOnly)
			.Where(m => {
				if (m.ReturnType != nothing)
					return false;
				ParameterInfo[] args = m.GetParameters();
				return args.Length == 1 && baseEvent.IsAssignableFrom(args[0].ParameterType);
			})
			.ToArray();
		foreach (MethodInfo handler in handlers) {
			Type evtType = handler.GetParameters()[0].ParameterType;
			Delegate converted = handler.CreateDelegate(typeof(Action<>).MakeGenericType(evtType), this);
			Console.WriteLine($"Registering handler {handler.Name} for {evtType.Name}");
			MethodInfo register = manager.MakeGenericType(evtType).GetMethod(nameof(EventManager<PathfinderEvent>.AddHandler), BindingFlags.Public | BindingFlags.Static);
			register.Invoke(null, [converted, default(EventHandlerOptions)]);
		}
		Console.WriteLine($"Handler registration complete ({handlers.Length} total)");

		Console.WriteLine($"{NAME} loaded successfully!");
		this.Loaded = true;
		return true;
	}

	private bool initConfig() {
		this.ActiveConfig = this.UserConfig ?? this.Config;
		this.ActiveConfig.SaveOnConfigSet = true;
		Console.WriteLine("Initialising settings...");
		if (ModSettings.Init()) {
			this.ActiveConfig.Save();
			return true;
		}
		Console.ForegroundColor = ConsoleColor.Red;
		Console.WriteLine("Failed to initialise settings!");
		Console.ResetColor();
		return false;
	}

	internal void GameOsLoaded(OSLoadedEvent evt) {
		ProgressionFlags flags = evt.Os.Flags;
		// this is the only way I can think of to grant this thing automatically UNLESS an extension is using it AND wants to specifically control when you get it
		if (!flags.HasFlag(FLAG_PREVENT_AUTO_ADD_EXE) && !flags.HasFlag(FLAG_HAS_AUTO_ADDED_EXE)) {
			Folder bin = evt.Os.thisComputer.files.root.getOrCreateFolder("bin");
			if (!bin.containsFileWithData(this.ProgramData))
				bin.files.Add(new(this.ProgramData, PROGRAM_NAME + ".exe"));
			flags.AddFlag(FLAG_HAS_AUTO_ADDED_EXE);
		}
	}
	internal void ExtensionLoaded(ExtensionLoadEvent evt) {
		Console.WriteLine($"{evt.Info.Name} {(evt.Unload ? "un" : "")}loaded, reloading settings");
		this.initConfig();
	}
	internal void TextReplacement(TextReplaceEvent evt) {
		evt.Replacement = evt.Replacement
			.Replace(BackdoorExploit.XML_ID_FOLDER, BackdoorExploit.FOLDER_NAME)
			.Replace(BackdoorExploit.XML_ID_FILENAME, BackdoorExploit.FILE_NAME)
			.Replace(BackdoorExploit.XML_ID_CONTENTS, BackdoorExploit.FileContents);
	}
	internal void TabCompletion(BuildAutocompletesEvent evt) => ModSettings.TabCompletion(evt);

	public override bool Unload() {
		singleton = null;
		return base.Unload();
	}
}
